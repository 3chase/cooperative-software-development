<!DOCTYPE html>
<html>
	<head>

		<meta name="viewport" content="width=device-width, initial-scale=1">

		<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
		
		<!-- Optional theme -->
		<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">
		
		<!-- Latest compiled and minified JavaScript -->
		<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
		
		<link rel="stylesheet" href="style.css" />

		<title>History</title>
		
	</head>
	<body>
		<p><a href="index.html">Back to table of contents</a></p>

		<img src="images/Hamilton.jpg" class="img-responsive" />		
		<small>Margaret Hamilton working on the Apollo flight software. <a href="By NASA - http://www.nasa.gov/50th/50th_magazine/scientists.html, Public Domain, https://commons.wikimedia.org/w/index.php?curid=37255847">Credit</a>.</small>
		
		<h1>History</h1>
		<div class="lead">Andrew J. Ko</div>

		<p>
			Computers haven't been around for long. 
			If you read one of the many histories of computing and information, such as James Gleick's <a href="https://www.amazon.com/Information-History-Theory-Flood/dp/1400096235">The Information</a>, or <a href="https://www.amazon.com/Tool-Partner-Evolution-Human-Computer-Interaction/dp/1627059636">Jonathan Grudin's History of HCI</a>, you'll learn that before <em>digital</em> computers, computers were people, calculating things manually, as portrayed in the film <a href="https://en.wikipedia.org/wiki/Hidden_Figures">Hidden Figures</a> (watch it if you haven't!). And that <em>after</em> digital computers, programming wasn't something that many people did. 
			It was reserved for whoever had access to the mainframe and they wrote their programs on punchcards like the one above. 
			Computing was in no way a ubiquitous, democratized activity&mdash;it was reserved for the few that could afford and maintain a room-sized machine.
		</p>
		
    <p>
			Because programming required such painstaking planning in machine code and computers were slow, most programs were not that complex. 
			Their value was in calculating things faster than a person could do by hand, which meant thousands of calculations in a minute rather than one calculation in a minute. 
			Computer programmers were not solving problems that had no solutions; they were translating existing solutions (for example, a quadratic formula) into the notation a computer understood. 
			Their power wasn't in creating new realities or facilitating new tasks, it was accelerating old tasks.
		</p>
	
		<p>
			The birth of software engineering, therefore, did not come until programmers started solving problems that <em>didn't</em> have existing solutions, or were new ideas entirely. 
			Most of these were done in academic contexts to develop things like basic operating systems and methods of input and output.  
			These were complex projects, but as research, they didn't need to scale; they just needed to work. 
			It wasn't until the late 1960s when the first truly large software projects were attempted commercially, and software had to actually perform.
		</p>
		
		<p>
			The IBM 360 operating system was one of the first big projects of this kind. 
			Suddenly, there were multiple people working on multiple components, all which interacted with one another. 
			Each part of the program needed to coordinate with the others, which usually meant that each part's <em>authors</em> needed to coordinate, and the term <em>software engineering</em> was born. 
			Programmers and academics from around the world, especially those who were working on big projects, created conferences so they could meet and discuss their challenges. 
			In the <a href="http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF">first software engineering conference</a> in 1968, attendees speculated about why projects were shipping late, why they were over budget, and what they could do about it.
		</p>
		
		<p>
			At the time, one of the key people behind coining the phrase software engineering was <a href="https://en.wikipedia.org/wiki/Margaret_Hamilton_(scientist)">Margaret Hamilton</a>, a computer scientist who was Director of the Software Engineering Division of the MIT Instrumentation Laboratory. 
			One of the lab's key projects in the late 1960's was developing the on-board flight software for the Apollo space program. 
			Hamilton led the development of error detection and recovery, the information displays, the lunar lander, and many other critical components, while managing a team of other computer scientists who helped. 
			It was as part of this project that many of the central problems in software engineering began to emerge, including verification of code, coordination of teams, and managing versions. 
			This led to one of her passions, which was giving software legitimacy as a form of engineering&mdash; at the time, it was viewed as routine, uninteresting, and simple work. 
			Her leadership in the field established the field as a core part of systems engineering.
		</p>
		
		<p>
			The first conference, the IBM 360 project, and Hamilton's experiences on the Apollo mission identified many problems that had no clear solutions:
		</p>
		
		<ul>
			<li>When you're solving a problem that doesn't yet have a solution, what is a good process for building a solution?</li>
			<li>When software does so many different things, how can you know software "works"?</li>
			<li>How can you make progress when <em>no one</em> on the team understands every part of the program?</li>
			<li>When people leave a project, how do you ensure their replacement has all of the knowledge they had?</li>
			<li>When no one understands every part of the program, how do you diagnose defects?</li>
			<li>When people are working in parallel, how do you prevent them from clobbering each other's work?</li>
			<li>If software engineering is about more than coding, what skills does a good coder need to have?</li>
			<li>What kinds of tools and languages can accelerate a programmers work and help them prevent mistakes?</li>
		</ul>
		
		<p>
			These questions are at the foundation of the field of software engineering and are the core content of this course. 
			Some of them have pretty good answers. 
			For example, the research community rapidly converged toward the concept of a version control systems, software testing, and a wide array of high-level programming languages such as Fortran (chronicled by <a href="#metcalf">Metcalf 2002</a>), LISP (chronicled <a href="mccarthy">McCarthy 1978</a>), C++ (chronicled by <a href="#stroustrup">Stroustrup 1996</a>), and Smalltalk (chronicled by <a href="#kay">Kay 1996</a>), all of which were precursors to today's modern languages such as Java, Python, and JavaScript.
		</p>
		
		<p>
			Other questions, particularly those concerning the <em>human</em> aspects of software engineering, have been hopelessly difficult to understand and improve. 
			One of the seminal books on these issues was Fred P. Brooks, Jr.'s <em>The Mythical Man Month</em>. 
			In it, he presented hundreds of claims about software engineering. 
			For example, he hypothesized that adding more programmers to a project would actually make productivity <em>worse</em> at some level, not better, because knowledge sharing would be an immense but necessary burden. 
			He also claimed that the <em>first</em> implementation of a solution is usually terrible and should be treated like a prototype: used for learning and then discarded. 
			These and other claims have been the foundation of decades of years of research, all in search of some deeper answer to the questions above.
		</p>
		
		<p>
			Other social aspects of software engineering have received considerably less treatment. 
			For example, despite the central role of women in programming the first digital computers, and the central role of women like Margaret Hamilton and Grace Hopper leading the formation of software engineering as a field in research and government, these histories are often forgotten, erased, and overshadowed by the gradual shift from software development being a field dominated by women to a field dominated by men. 
			Many texts are beginning to document the central role of sexism that was at the heart of causing this culture shift (e.g., <a href="">Abbate 2012</a>). 
			These histories show that, just like any other human activity, there are strong cultural forces that shape how people engineer software together.
		</p>
		
		<p>
			If we step even further beyond software engineering as an activity and think more broadly about the role that software is playing in society today, there are also other, newer questions that we've only begun to answer. 
			If every part of society now runs on code, what responsibility do software engineers have to ensure that code is right? 
			What responsibility do software engineers have to avoid algorithmic bias? 
			If our cars are to soon drive us around, who's responsible for the first death: the car, the driver, or the software engineers who built it, or the company that sold it? 
			These ethical questions are in some ways the <em>future</em> of software engineering, likely to shape its regulatory context, its processes, and its responsibilities.
		</p>
		
		<p>
			There are also <em>economic</em> roles that software plays in society that it didn't before. 
			Around the world, software is a major source of job growth, but also a major source of automation, eliminating jobs that people used to do. 
			These larger forces that software is playing on the world demand that software engineers have a stronger understanding of the roles that software plays in society, as the decisions that engineers make can have profoundly impactful unintended consequences.
		</p>

		<p>
			We're nowhere close to having deep answers about these questions, neither the old ones or the new ones. 
			We know <em>a lot</em> about programming languages and <em>a lot</em> about testing. 
			These are areas amenable to automation and so computer science has rapidly improved and accelerated these parts of software engineering. 
			The rest of it, as we shall see in this, has not made much progress. 
			In this class, we'll discuss what we know and the much larger space of what we don't.
		</p>

		<center class="lead"><a href="organizations.html">Next chapter: Organizations</a></center>

		<h2>Further reading</h2>

		<p>Abbate, Janet (2012). <a href="https://mitpress.mit.edu/books/recoding-gender">Recoding Gender: Women's Changing Participation in Computing</a>. The MIT Press.</a>
		<p>Brooks Jr, F. P. (1995). <a href="https://books.google.com/books?id=Yq35BY5Fk3gC" target="_blank">The Mythical Man-Month (anniversary ed.)</a>. Chicago</p>
		<p>Gleick, James (2011). <a href="https://books.google.com/books?id=617JSFW0D2kC" target="_blank">The Information: A History, A Theory, A Flood</a>. Pantheon Books.</p>
		<p>Grudin, Jonathan (2017). <a href="https://books.google.com/books?id=Wc3hDQAAQBAJ" target="_blank">From Tool to Partner: The Evolution of Human-Computer Interaction</a>.</p>
		<p id="kay">Kay, A. C. (1996, January). <a href="http://dl.acm.org/citation.cfm?id=1057828" target="_blank">The early history of Smalltalk</a>. In History of programming languages---II (pp. 511-598). ACM.</p>
		<p>Ko, A. J. (2016). <a href="http://softwareengineeringdaily.com/2016/02/24/academia-to-industry-in-computer-science-with-andy-ko/">Interview with Andrew Ko on Software Engineering Daily about Software Engineering Research and Practice</a>.</p>
		<p id="mccarthy">McCarthy, J. (1978, June). <a href="http://dl.acm.org/citation.cfm?id=1198360" target="_blank">History of LISP</a>. In History of programming languages I (pp. 173-185). ACM.</p>
		<p id="metcalf">Metcalf, M. (2002, December). <a href="http://dl.acm.org/citation.cfm?id=602379" target="_blank">History of Fortran</a>. In ACM SIGPLAN Fortran Forum (Vol. 21, No. 3, pp. 19-20). ACM.</p>
		<p id="stroustrup">Stroustrup, B. (1996, January). <a href="http://dl.acm.org/citation.cfm?id=1057836" target="_blank">A history of C++: 1979--1991</a>. In History of programming languages---II (pp. 699-769). ACM.</p>

		<script type="text/javascript">
		
			var _gaq = _gaq || [];
			_gaq.push(['_setAccount', 'UA-10917999-1']);
			_gaq.push(['_trackPageview']);
			
			(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
			})();
		
		</script>

	</body>

</html>



